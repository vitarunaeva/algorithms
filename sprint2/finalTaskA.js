/**
 ДЕК
 Гоша реализовал структуру данных Дек, максимальный размер которого определяется заданным числом. Методы push_back(x), push_front(x), pop_back(), pop_front() работали корректно. Но, если в деке было много элементов, программа работала очень долго. Дело в том, что не все операции выполнялись за O(1). Помогите Гоше! Напишите эффективную реализацию.

 Внимание: при реализации нельзя использовать связный список.

 Формат ввода
 В первой строке записано количество команд n — целое число, не превосходящее 100000. Во второй строке записано число m — максимальный размер дека. Он не превосходит 50000. В следующих n строках записана одна из команд:

 push_back(value) – добавить элемент в конец дека. Если в деке уже находится максимальное число элементов, вывести «error».
 push_front(value) – добавить элемент в начало дека. Если в деке уже находится максимальное число элементов, вывести «error».
 pop_front() – вывести первый элемент дека и удалить его. Если дек был пуст, то вывести «error».
 pop_back() – вывести последний элемент дека и удалить его. Если дек был пуст, то вывести «error».
 Value — целое число, по модулю не превосходящее 1000.
 Формат вывода
 Выведите результат выполнения каждой команды на отдельной строке. Для успешных запросов push_back(x) и push_front(x) ничего выводить не надо.

 Example:
 Ввод:
 4
 4
 push_front 861
 push_front -819
 pop_back
 pop_back

 Вывод:
 861
 -819
 */

const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
});

const result = [];

rl.prompt();

rl.on('line', (line) => {
    result.push(line);
})

rl.on('close', () => {
    processData(result);
})

function processData(elements) {
    const maxSizeDeque = +elements[1];
    const deque = new Deque(maxSizeDeque);
    let result;

    for (let i = 2; i < elements.length; i++) {
        const command = elements[i].split(' ');

        switch (command[0]) {
            case 'push_back':
                result = deque.pushBack(+command[1]);
                break;
            case 'push_front':
                result = deque.pushFront(+command[1]);
                break;
            case 'pop_front':
                result = deque.popFront();
                break;
            case 'pop_back':
                result = deque.popBack();
                break;
            default:
                return;
        }

        if (result !== undefined) {
            console.log(result);
        }
    }
}

class Deque {
    constructor(maxSize = 0) {
        this.items = [];
        this.head = 0;
        this.tail = 1;
        this.itemsSize = 0;
        this.maxSize = maxSize;
    }

    pushBack(value) {
        if (this._isFull()) {
            return 'error';
        }

        this.tail = (this.tail || this.maxSize) - 1;
        this.items[this.tail] = value;
        this.itemsSize++;
    }

    pushFront(value) {
        if (this._isFull()) {
            return 'error';
        }

        this.head = (this.head + 1) % this.maxSize;
        this.items[this.head] = value;
        this.itemsSize++;
    }

    popFront() {
        if (this._isEmpty()) {
            return 'error';
        }

        const value = this.items[this.head];
        this.items[this.head] = 'None';

        this.head = (this.head || this.maxSize) - 1;
        this.itemsSize--;
        return value;
    }

    popBack() {
        if (this._isEmpty()) {
            return 'error';
        }

        const value = this.items[this.tail];
        this.items[this.tail] = 'None';

        this.tail = (this.tail + 1) % this.maxSize;
        this.itemsSize--;
        return value;
    }

    _isEmpty() {
        return this.itemsSize === 0;
    }

    _isFull() {
        return this.itemsSize === this.maxSize;
    }
}

/*
-- ПРИНЦИП РАБОТЫ --
Так как в условиях задачи сказано, что нельзя использовать связный список и задан максимальный размер дека,
    двустороння очередь реализована по принципу очереди на кольцевом буфере из урока
Яндекс.Практикум "Структура данных очередь. Реализация",
    с добавлением методов вставки в начало и удаление из конца очереди.

    В классе Deque создается динамический массив и содержатся поля:
    - head (указатель на начало очереди);
- tail (указатель на конец очереди);
- maxSize (максимально возможное количество элементов в очереди. По умолч. = 0);
- itemsSize (размер очереди).

Методы класса:
    - pushFront(value) - добавляет элемент в начало очереди,
    увеличивая значение размера очереди (itemsSize) и указатель на начало очереди смещается
на следующую позицию по модулю (head).

- popBack() - выводит и удаляет элемент, добавленный раньше всех (первый в очереди) и уменьшает значение размера
очереди (itemsSize).Указатель на конец очереди (tail) изменяется аналогично полю head в методе pushFront,
    так как при извлечении следующего элемента необходимо будет удалять элемент из ячейки i + 1 по циклу.

- pushBack(value) - добавляет элемент в конец очереди, увеличивая значение размера очереди (itemsSize).
    Конец очереди (tail) смещается на предыдущюю позицию.

- popFront() - выводит и удаляет элемент, добавленный позже всех (последний в очереди)
и уменьшает размер очереди (itemsSize).
    Указатель начала списка смещается на позицию назад.

- private isEmpty() - проверяет что очередь пустая

- private isFull() - проверяет что очередь переполнена

В операциях добавления, если дек уже содержит максимально возможное кол-во элементов, то выводится 'error'.
    В операциях удаления, если дек на момент удаления пуст, то выводится 'error'.


-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Deque предсталвляет собой тип очереди, в которой добавление и удаление элемента может выполняться как с конца, так
и с начала очереди.  Таким образом, двусторонняя очередь поддерживает как FIFO, так и LIFO.
    В данной реализации учитывается переполнение и обрабатывается извлечение из пустоко дека.
    Смещение указателей требуется для того, чтобы конец очереди (tail) всегда указывал на первую свободную для записи ячейки,
    а начало очереди (head) - на элемент, который добавлен в очередь раньше остальных.
    В отличие от связного списка, который требует создание дополнительных узлов и
элементы могут располагаться в любом месте памяти, реализация с помощью массива является более производительной
и предоставляет возможность повтороного использования кода.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Так как при реализации дека требовалось реализовать добавление элемента только в начало или конец списка,
    временная сложность составляет О(1).
    В растущем массиве амортизированная временная сложность составляет О(1).

// FIXED:
    Время алгоритма зависит от количества передаваемых на вход данных. Так, чем больше данных передано, тем больше операций
необходимо выполнить. Соотвественно, алгоритм имеет линейную зависимость и вычислительная сложность обработки всех входных данных
составляет О(n), где n - количество команд.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

// FIXED:
Так как буфер задан не фиксированным размером, а ограничен только максимальным размером,
    то рост памяти является динамическим и прямопропорционален количеству команд, соотвественно алгоритм занимает O(n) памяти.
    Вспомогательная память требуется для хранения переменных: 2-х указателей, счетчика размера и максимального размера буфера,
    которые занимают фиксированный объем памяти, не зависящий от длины дека. Таким образом, требуется О(1) дополнительной памяти.
*/

