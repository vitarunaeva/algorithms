/**
 ПОИСК В СЛОМАННОМ МАССИВЕ
 Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время. Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной последовательности. Теперь массив не является отсортированным. Тем не менее, нужно обеспечить возможность находить в нем элемент за
 O(logn).
 Можно предполагать, что в массиве только уникальные элементы.
 От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве.

 Формат ввода
 Функция принимает массив натуральных чисел и искомое число k. Длина массива не превосходит 10000. Элементы массива и число k не превосходят по значению 10000.
 В примерах:
 В первой строке записано число n –— длина массива.
 Во второй строке записано положительное число k –— искомый элемент.
 Далее в строку через пробел записано n натуральных чисел, каждое из которых не превосходит 200000.

 Формат вывода
 Функция должна вернуть индекс элемента, равного k, если такой есть в массиве (нумерация с нуля).
 Если элемент не найден, функция должна вернуть − 1.
 Изменять массив нельзя.
 Для отсечения неэффективных решений ваша функция будет запускаться от 100000 до 1000000 раз.

 Example:
 Ввод:
 9
 5
 19 21 100 101 1 4 5 7 12

 Вывод:
 6
 */

function brokenSearch(arr, k, left = 0, right = arr.length - 1) {

    if (right < left) {
        return -1;
    }

    const mid = (left + right) >> 1;

    if (arr[mid] === k) {
        return mid;
    }

    if (arr[left] <= arr[mid]) {

        if (k >= arr[left] && k < arr[mid]) {
            return brokenSearch(arr, k, left, mid - 1);
        }

        return brokenSearch(arr, k, mid + 1, right);
    }

    if (k > arr[mid] && k <= arr[right]) {
        return brokenSearch(arr, k, mid + 1, right);
    }

    return brokenSearch(arr, k, left, mid - 1);
}

function test() {
    const arr = [5, 1];
    if (brokenSearch(arr, 5) !== 6) {
        console.error("WA");
    }
}

//test()


/*
 -- ПРИНЦИП РАБОТЫ --

 Для решения задачи использовался бинарный поиск заданного значения.
 Функция сортировки принимает 4 параметра:
 - массив;
 - искомое значение;
 - индексы левой и правой границ, на котором производится поиск.

 1) Задаются начальные индексы left и right [0, arrLength).
 2) Определяется средний индекс массива;
 3) Проверяется, равен ли центральный элемент искомому. Если равен, то индекс возвращается.
 4) Рекурсивный поиск в левой части массива:
    если искомое число принадлежит значениям на отрезке [left, mid), то область поиска справа сужается на 1,
    иначе область поиска меняется на правую часть массива (mid, right];
 5) Если в правой части число не найдено, рекурсивный поиск в правой части массива:
       если искомое число принадлежит значениям на отрезке (mid, right], то правая область поиска уменьшается,
       иначе запускается поиск в левой части поиска.

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
В целом список не является отсортированным, но технически разделен на две отсортированные части, поэтому для
решения поставленной задачи подходит бинарный поиск.

На каждом шаге сужается диапазон поиска (правая граница сдвигается влево, или левая - враво).
Рекурсия не уходит в бесонечный поиск, так как предусмотрены базовые случаи:
 1) левая граница (left) становится больше правой (right) (число не найдено);
 2) центральный элемент равен искомому числу k.

 -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Расчитывается с учетом сколько раз массив на 2, пока не будет найден необходимый элемент.
На поиск тратится половина времени,поэтому нет необходимости перебирать каждый элемент, массив уменьшается логарифмически.
Соотвественно, сложность составляет O(log N)

 -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Аналогична временной - O(log N), так как рекурсивный поиск хранит вызов метода в стеке.
 */
