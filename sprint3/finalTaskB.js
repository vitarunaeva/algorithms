/**
 ЭФФЕКТИВНАЯ БЫСТРАЯ СОРТИРОВКА

 Тимофей решил организовать соревнование по спортивному программированию, чтобы найти талантливых стажёров. Задачи подобраны, участники зарегистрированы, тесты написаны. Осталось придумать, как в конце соревнования будет определяться победитель.

 Каждый участник имеет уникальный логин. Когда соревнование закончится, к нему будут привязаны два показателя: количество решённых задач Pi и размер штрафа Fi. Штраф начисляется за неудачные попытки и время, затраченное на задачу.

 Тимофей решил сортировать таблицу результатов следующим образом: при сравнении двух участников выше будет идти тот, у которого решено больше задач. При равенстве числа решённых задач первым идёт участник с меньшим штрафом. Если же и штрафы совпадают, то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.

 Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин. В своё отсутствие он поручил вам реализовать алгоритм быстрой сортировки (англ. quick sort) для таблицы результатов. Так как Тимофей любит спортивное программирование и не любит зря расходовать оперативную память, то ваша реализация сортировки не может потреблять O(n) дополнительной памяти для промежуточных данных (такая модификация быстрой сортировки называется "in-place").

 Как работает in-place quick sort
 Как и в случае обычной быстрой сортировки, которая использует дополнительную память, необходимо выбрать опорный элемент (англ. pivot), а затем переупорядочить массив. Сделаем так, чтобы сначала шли элементы, не превосходящие опорного, а затем —– большие опорного.

 Затем сортировка вызывается рекурсивно для двух полученных частей. Именно на этапе разделения элементов на группы в обычном алгоритме используется дополнительная память. Теперь разберёмся, как реализовать этот шаг in-place.

 Пусть мы как-то выбрали опорный элемент. Заведём два указателя left и right, которые изначально будут указывать на левый и правый концы отрезка соответственно. Затем будем двигать левый указатель вправо до тех пор, пока он указывает на элемент, меньший опорного. Аналогично двигаем правый указатель влево, пока он стоит на элементе, превосходящем опорный. В итоге окажется, что что левее от left все элементы точно принадлежат первой группе, а правее от right — второй. Элементы, на которых стоят указатели, нарушают порядок. Поменяем их местами (в большинстве языков программирования используется функция swap()) и продвинем указатели на следующие элементы. Будем повторять это действие до тех пор, пока left и right не столкнутся.
 На рисунке представлен пример разделения при pivot=5. Указатель left — голубой, right — оранжевый.

 Формат ввода
 В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
 В каждой из следующих n строк задана информация про одного из участников.
 i-й участник описывается тремя параметрами:

 уникальным логином (строкой из маленьких латинских букв длиной не более 20)
 числом решённых задач Pi
 штрафом Fi
 Fi и Pi — целые числа, лежащие в диапазоне от 0 до 109.
 Формат вывода
 Для отсортированного списка участников выведите по порядку их логины по одному в строке.

 Example:
 Ввод:
 5
 alla 4 100
 gena 6 1000
 gosha 2 90
 rita 2 90
 timofey 4 80

 Вывод:
 gena
 timofey
 alla
 gosha
 rita
 */

const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: ''
});

const result = [];

rl.prompt();

rl.on('line', (line) => {
    result.push(line);
})

rl.on('close', () => {
    console.log(getSortedNames(result));
})

function getSortedNames(elements) {
    const personsCount = +elements[0];
    const persons = elements.splice(1, personsCount).map(item => new Persons(...item.split(' ')));

    quickSort(persons, 0, personsCount - 1);

    return persons.map(person => person.name).join('\n');
}

function quickSort(arr, left, right) {
    if (left >= right) {
        return;
    }

    let start = left;
    let end = right;
    const pivot = arr[((right + left) >> 1)];

    while (start < end) {
        while (checkLeftPointer(arr[start], pivot)) {
            start++;
        }

        while (checkRightPointer(arr[end], pivot)) {
            end--;
        }

        swap(arr, start, end);

        if (start === end) {
            start++;
            end--;

            quickSort(arr, left, start - 1);
            quickSort(arr, start, right);
        }
    }
}

function swap(items, left, right) {
    const leftItems = items[left];
    items[left] = items[right];
    items[right] = leftItems;
}

function checkLeftPointer(leftPointer, pivot) {
    if (leftPointer.solved === pivot.solved) {
        if (leftPointer.errors === pivot.errors) {
            return leftPointer.name < pivot.name;
        }

        return leftPointer.errors < pivot.errors;
    }

    return leftPointer.solved > pivot.solved;
}

function checkRightPointer(rightPointer, pivot) {

    if (rightPointer.solved === pivot.solved) {
        if (rightPointer.errors === pivot.errors) {
            return rightPointer.name > pivot.name;
        }

        return rightPointer.errors > pivot.errors;
    }
    return rightPointer.solved < pivot.solved
}


class Persons {
    constructor(name = '', solved = null, errors = null) {
        this.name = name;
        this.solved = +solved;
        this.errors = +errors;
    }
}

/*
-- ПРИНЦИП РАБОТЫ --
Для реализации алгоритма использовался принцип разбиения Хоара.
1) Устанавливаются указатели. Левый - с первого элемента в массиве. Правый - с последнего элемента.
2) В массиве находится опорный элемент среди кол-ва решенных задач (solved) - pivot.
   В качестве опорного элемента берется центральное значение.
3) Пока значение левого указателя в массиве меньше, чем значение опорного элемента, левый указатель (start) сдвигается вправо.
   В случае равенства числа решенных задач, сравниваются количество штрафов. Левый указатель сдвигается, если левое значение меньше опорного errors.
   В случае равенства числа штрафов, сравниваются имена участников. Левый указатель сдвигается, если опорное значение имени идет раньше в алфавитном порядке, чем левое.
4) Пока значение правого указателя в массиве больше, чем значение опорного элемента, правый указатель (end) сдвигается влево.
   В случае равенства числа решенных задач, сравниваются количество штрафов. Правый указатель сдвигается, если правое значение больше опорного errors.
   В случае равенства числа штрафов, сравниваются имена участников. Правый указатель сдвигается, если опорное значение имени идет позже в алфавитном порядке, чем правое.
5) Элементы, на которых стоят указатели, нарушают порядок и меняются местами (swap()).
6) Если правый указатель равен левому указателю, левый указатель сдвигается на одну позицию вправо, а правый - влево,
   и заново запускается сортировка для обеих частей массива (Переход к шагу 1).


-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
В отлчие от алгоритма быстрой сортировки, описанной в теории курса, представленная программа не использует
вспомогательные массивы, а работает с указателями и сортирует исходный массив, что позволило избежать использования дополнительной памяти.

В качестве опорного элемента выбрано центральное значение массива, так как выбор первого и последнего элемента работает только в неотсортированных массивах,
а отсортированный массив будет являться killer-последователньостью.
Можно было выбрать рандомное значение в массиве, но это требует дополнительных вычислений.

В случае, если сравниваемые элементы количества задач совпадают, проверяется количество штрафов. Если и в этом случае значения одинаковые,
то проверяются имена. Логины участников являются одинаковыми, поэтому при этом сравнении не может быть совпадений.

Программа не проваливается в "кроличью нору" рекурсии, так как предусмотрен базовый случай:
если индекс левой части достигает индекса правой, сортировка заканчивается.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Время алгоритма зависит от количества разбиений массива. Так как каждая последовательность разбиения будет давать свое дерево обработки.
Поэтому количество операций логарифмически зависит от количества элементов.
Таким образом, временная сложность получится О(n log n);

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Сортировка использует дополнительную память, т.к. глубина рекурсии приблизительно составляет O(log n),
а данные о рекурсивных вызовах добавляются в стек.
*/
